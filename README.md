# AQUANIKA — многостраничный сайт салона красоты

Полноценный проект многостраничного сайта салона красоты AQUANIKA на Vite 5 с модульной архитектурой, адаптивной вёрсткой, ленивой загрузкой изображений, продуманной структурой страниц и конфигурацией для локальной разработки и продакшен-сборки.

Сайт: aquanika74.ru (боевой хостинг)
Демо (репозиторий/артефакты): gana74.github.io/AQUANIKA

## Содержание

- Обзор
- Технологии
- Структура проекта
- Требования окружения
- Установка и запуск
- Скрипты npm
- Конфигурация сборки (Vite)
- Маршрутизация и входные точки
- Работа с ассетами и производительность
- Безопасность и заголовки
- Качество кода
- Деплой (варианты)
- Типичные задачи разработки
- FAQ / Траблшутинг
- Автор

## Обзор

Проект реализует гибридную архитектуру: **SPA-роутинг с фрагментами HTML**. Основная страница (`index.html`) загружается один раз, а контент страниц динамически подгружается из фрагментов через JavaScript роутер. Это обеспечивает быструю навигацию без полной перезагрузки страницы, при этом сохраняя SEO-метатеги и правильные URL.

### Реализованные решения

**Проблема:** Конфликт между SPA-роутером (загружает HTML через `fetch()`) и Apache (пытается отдать файлы напрямую).

**Решение:**

1. ✅ Перенесены файлы из `src/pages/` → `src/fragments/` (фрагменты для роутера)
2. ✅ Обновлен роутер для использования `/fragments/` вместо `/pages/`
3. ✅ Настроен `.htaccess` для блокировки прямого доступа к `/fragments/*.html` (403 Forbidden)
4. ✅ Разрешена загрузка фрагментов только через `fetch()` с заголовком `X-Requested-With: XMLHttpRequest`
5. ✅ Добавлено автоматическое обновление мета-тегов (title, description, canonical, Open Graph) из фрагментов
6. ✅ Настроен плагин Vite для копирования фрагментов в `dist/fragments/` при сборке

**Результат:** Пользователи не могут напрямую открыть `/fragments/about.html` (блокируется), но могут использовать правильные маршруты (`/about`), которые загружают полную страницу со стилями через SPA-роутер.

**Архитектура:**

- `src/index.html` — главная точка входа (SPA-оболочка)
- `src/fragments/*.html` — HTML-фрагменты контента страниц (загружаются через роутер)
- `src/components/partials/` — повторно используемые компоненты (header, footer, side-menu)
- Роутер (`src/js/components/router.js`) — управляет навигацией и загрузкой фрагментов

Сборка основана на Vite 5: быстрое локальное развитие, оптимизация, разбиение по чанкам, копирование публичных файлов, явная конфигурация входных точек Rollup, alias-пути и загрузка SVG как модулей.

## Технологии

- HTML5
- CSS3 (адаптивная сетка, методология BEM, code-splitting CSS)
- JavaScript ES6+ (модули)
- Vite 5 (dev-сервер, сборка, оптимизация)
- Rollup (в составе Vite) — многовходовая сборка
- Font Awesome (@fortawesome/fontawesome-free) — иконки
- lazysizes — ленивая загрузка изображений
- ESLint, Stylelint — качество кода

## Структура проекта

Корень репозитория:

- src/ — исходники
  - assets/ — изображения, шрифты, видео, иконки и др.
  - components/partials/ — HTML-фрагменты (header, footer, side-menu)
  - js/ — JS-модули (главная логика, компоненты, утилиты)
    - components/router.js — SPA-роутер для навигации и загрузки фрагментов
  - fragments/ — HTML-фрагменты контента страниц (загружаются через роутер)
  - styles/ — стили (базовые, компоненты, страницы)
  - index.html — корневой HTML (SPA-оболочка)
- public/ — статические файлы, копируются «как есть» в сборку
  - .htaccess — правила Apache для SPA-роутинга и безопасности
- dist/ — выходная директория production-сборки (создаётся Vite)
- docs/ — может использоваться как артефакты для GitHub Pages (если включено)
- package.json — скрипты, зависимости, browserslist
- vite.config.js — конфигурация Vite/Rollup, dev-server rewrites, alias, плагины
- copy-fonts.js — утилита копирования шрифтов из Font Awesome
- .gitignore, README.md и пр.

**Важно:** Фрагменты в `src/fragments/` копируются в `dist/fragments/` при сборке через плагин Vite. Они предназначены только для загрузки через JavaScript роутер, прямой доступ к `/fragments/*.html` блокируется через `.htaccess`.

## Требования окружения

- Node.js 18+ (Vite 5 требует Node >= 18)
- npm 9+ (или соответствующая версия к Node)

Проверка версий:

- node -v
- npm -v

## Установка и запуск

1. Клонировать репозиторий:

- git clone https://github.com/Gana74/AQUANIKA.git
- cd AQUANIKA

2. Установить зависимости:

- npm install

3. Запустить dev-сервер:

- npm run dev

По умолчанию сервер стартует на http://localhost:3000 и открывает браузер автоматически.

## Скрипты npm

- dev — запуск Vite dev-сервера (порт 3000, open: true)
- build — production-сборка (предварительно копирует шрифты Font Awesome)
- preview — локальный предпросмотр собранного проекта
- lint:js — проверка JS-файлов (eslint src/\*_/_.js)
- lint:css — проверка CSS-файлов (stylelint src/\*_/_.css)
- clean — удаление папки docs (наследие/служебный скрипт)
- deploy — выполнить build и вывести подсказку по выгрузке содержимого dist на боевой хостинг
- copy:fonts — копирование woff2 шрифтов из @fortawesome в assets

Команды запускаются через:

- npm run <script>

## Конфигурация сборки (Vite)

Файл vite.config.js:

- root: src — корень исходников для dev и build
- base: / — базовый путь (для деплоя на поддомен/подпуть при необходимости меняется)
- publicDir: ../public — содержимое копируется как есть
- build:
  - outDir: ../dist — итоговая папка сборки (в корне)
  - emptyOutDir: true — очистка папки перед сборкой
  - assetsDir: assets — каталог для статики внутри dist
  - cssCodeSplit: true — разбиение CSS по чанкам
  - minify: true — минификация
  - sourcemap: false — исходные карты в продакшене выключены
  - copyPublicDir: true
  - rollupOptions.input — список HTML-энтрипоинтов (каждая страница/часть)
  - rollupOptions.output.manualChunks — явное выделение чанка sideMenu
- server:
  - port: 3000, open: true
  - historyApiFallback.rewrites — правила для «красивых» путей в dev-режиме
- resolve.alias: { '@': 'src' }
- assetsInclude: ["**/*.svg"]
- plugins: простой pre-плагин для импорта SVG как строк-модулей

## Маршрутизация и входные точки

Проект использует **SPA-архитектуру с фрагментами HTML**:

**Как это работает:**

1. Пользователь переходит на `/about` → Apache отдает `index.html` (SPA fallback)
2. Роутер определяет маршрут `/about` и загружает контент из `/fragments/about.html` через `fetch()`
3. Контент извлекается из `<main>` фрагмента и вставляется в `<main>` основной страницы
4. Мета-теги (title, description, canonical, Open Graph) обновляются из фрагмента

**Структура фрагментов:**

- `src/fragments/home.html` — главная страница
- `src/fragments/about.html` — о нас
- `src/fragments/price.html` — прайс
- `src/fragments/contacts.html` — контакты
- И т. д. (см. полный список в `src/js/components/router.js`)

**Безопасность:**

- Прямой доступ к `/fragments/*.html` блокируется через `.htaccess` (403 Forbidden)
- Фрагменты доступны только через `fetch()` с заголовком `X-Requested-With: XMLHttpRequest`
- Это предотвращает загрузку фрагментов без стилей при прямом переходе

**Dev-сервер:**
Настроены rewrites для удобной разработки:

- `/services/cosmetology/face-care` → `/fragments/face-care.html`
- `/services/nails/manicure` → `/fragments/manicure.html`
- И т. п.

Повторяющиеся части (header, footer, side-menu) вынесены в `components/partials` и динамически подгружаются через JS.

## Работа с ассетами и производительность

- Изображения и медиа — в src/assets (в продакшене попадают в dist/assets). Для изображений используется lazysizes: добавляйте data-src и класс lazyload для ленивой загрузки.
- Иконки — @fortawesome/fontawesome-free. Шрифты woff2 копируются командой copy:fonts (автоматически вызывается внутри npm run build) в нужную директорию ассетов.
- CSS разрезается по чанкам (cssCodeSplit), что уменьшает размер критического пути и ускоряет загрузку.
- SVG импортируются как модули (плагин в vite.config.js), что позволяет инлайнить или обрабатывать их как строки.

Рекомендации по изображениям:

- Использовать современные форматы (WebP/AVIF) с fallback при необходимости
- Настраивать размеры и атрибуты width/height
- Применять responsive изображения (srcset, sizes) на ключевых блоках

## Безопасность и заголовки

- В `public/.htaccess` настроены:
  - **Заголовки безопасности**: HSTS, CSP, Referrer-Policy, X-Content-Type-Options, Permissions-Policy и др.
  - **SPA-роутинг**: все маршруты (`/about`, `/services/*` и т.д.) перенаправляются на `index.html`
  - **Блокировка фрагментов**: прямой доступ к `/fragments/*.html` запрещен (403 Forbidden), доступ только через `fetch()` с заголовком `X-Requested-With`
  - **Кэширование**: оптимизированные правила для статики и HTML
- Формы могут отправляться через Formspree; онлайн-запись — через YCLIENTS (открытие во внешнем окне). При интеграции уточняйте ключи/идентификаторы в соответствующих JS-модулей форм/виджетов.

## Качество кода

- ESLint: npm run lint:js — проверяет все JS-файлы в src
- Stylelint: npm run lint:css — проверяет все CSS-файлы в src

Рекомендации:

- Соблюдать BEM в классах
- Разбивать стили по компонентам/страницам
- Избегать глобальных утечек в JS, использовать ES-модули
- Держать общие утилиты в src/js/components или src/js/utils

## Деплой (варианты)

1. Веб-хостинг (боевой):

- npm run build
- Загрузить содержимое папки dist на сервер (корень сайта или соответствующую директорию в зависимости от настроек домена aquanika74.ru)
- Убедиться, что заголовки из public/.htaccess применяются (для Apache). Для Nginx перенести правила в конфиг.

2. GitHub Pages (вариант с «/docs»):

- В текущей конфигурации outDir = dist, но можно поменять на docs или использовать Actions
- Либо включить Pages из ветки main, папка /docs (при этом скорректировать outDir и base)

3. GitHub Pages (через gh-pages):

- Можно использовать пакет gh-pages (уже в devDependencies) и скрипт deploy (нужна доработка под push). В текущем скрипте deploy выводит инструкцию после build. При желании заменить на автоматическую публикацию в gh-pages.

Важные моменты:

- Если проект разворачивается на подпути (например, /AQUANIKA/), обязательно установить корректный base в vite.config.js (сейчас установлен "/"). Для GitHub Pages под репозиторием обычно требуется base: "/AQUANIKA/".
- После смены base пересоберите проект: npm run build.

## Типичные задачи разработки

- Добавить новую страницу:

  1. Создать файл в `src/fragments/<имя>.html` с полной структурой HTML (включая `<head>` с мета-тегами и `<main>` с контентом)
  2. Добавить маршрут в `src/js/components/router.js` в объект `routes` (например, `"/new-page": "/fragments/new-page.html"`)
  3. Добавить заголовок страницы в объект `pageTitles` в `router.js`
  4. При необходимости добавить rewrite для dev-сервера в `vite.config.js` → `server.historyApiFallback.rewrites`
  5. Фрагмент автоматически скопируется в `dist/fragments/` при сборке

- Добавить новый компонент:

  1. Разместить HTML-фрагмент в `src/components/partials`
  2. При динамической загрузке — добавить JS-инициализацию в `src/js/components`
  3. Подключить стили компонента в соответствующий CSS

- Подключить новый шрифт:
  1. Добавить файлы в `src/assets/fonts` (или расширить `copy-fonts.js`)
  2. Описать `@font-face` в стилях

## FAQ / Траблшутинг

- Белый экран после деплоя на подпуть:
  - Проверьте, что `base` в `vite.config.js` соответствует конечному URL (например, "/AQUANIKA/").
- 404 в dev при переходах по «красивым» URL:
  - Убедитесь, что есть правило в `rewrites` для данного пути, и оно указывает на нужный HTML-файл в `/fragments`.
- Страница загружается без стилей при прямом переходе на `/fragments/about.html`:
  - Это нормальное поведение — фрагменты блокируются для прямого доступа. Используйте правильные маршруты (`/about`, `/services/spa` и т.д.), которые загружают `index.html` с роутером.
- Роутер не загружает фрагменты:
  - Проверьте, что файлы скопированы в `dist/fragments/` после сборки (плагин `copy-fragments-and-images` в `vite.config.js`)
  - Убедитесь, что роутер отправляет заголовок `X-Requested-With: XMLHttpRequest` в `fetch()` запросах
- Иконки Font Awesome не отображаются:
  - Убедитесь, что выполнено копирование шрифтов (`npm run build` вызывает `copy:fonts`), либо запустите `npm run copy:fonts` вручную в dev и проверьте пути.
- Неприменяются заголовки безопасности/кэширования:
  - Для Apache проверьте, что `AllowOverride` включён и `.htaccess` читается сервером; для других серверов адаптируйте правила.

## Автор

- Gana74 — https://github.com/Gana74
